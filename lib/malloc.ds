/*DS Copyright (C) 2011 David Hill
**
** Permission to use, copy, modify, and/or distribute this software for any
** purpose with or without fee is hereby granted, provided that the above
** copyright notice and this permission notice appear in all copies.
**
** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
** REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
** AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
** INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
** LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
** OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
** PERFORMANCE OF THIS SOFTWARE.
*/

/* malloc.ds
**
** Dynamic memory management.
**
** This is the "normal" implementation, intended to be as general-purpose as
** reasonably possible.
*/

[

#include "malloc.dh"



// Heap is in addressable space, global0.
void var registerarray_global array int[0] __heap @ 0;

// Store index between calls to malloc for efficiency.
void var register_map int __heap_index;

// Heap starts after automatic variable stack and static variable section of
// addressable space.
void const int __heap_start = 8192 + (24*1024);

struct __heap_block
{
	int used;
	int size;
};



function free(void * p) -> void
{
	if (!p) return;

	void var register int index = int p - 2;

	void __heap[index] = 0;

	if (index < __heap_index)
		void __heap_index = index;
};
function free_all() -> void
{
	void __heap_index = __heap_start;
	void __heap[__heap_start] = __heap[__heap_start+1] = 0;
};

function malloc(int size) -> void *
{
	if (size < 1) void size = 1;

	if (!__heap_index) void __heap_index = __heap_start;

	// Keep looking until we wrap the index around.
	while (__heap_index >= 0)
	{
		// Used block.
		if (__heap[__heap_index])
		{
			void __heap_index += __heap[__heap_index+1] + 2;
			continue;
		};

		// Unused block.
		if (__heap[__heap_index+1])
		{
			if (__heap[__heap_index+1] >= size)
			{
				void __heap[__heap_index] = size;
				return __heap_index+2;
			}
			else
			{
				void __heap_index += __heap[__heap_index+1] + 2;
				continue;
			};
		};

		// No block.
		void __heap[__heap_index] = __heap[__heap_index+1] = size;
		void __heap[__heap_index+size+2] = __heap[__heap_index+size+3] = 0;
		return __heap_index+2;
	};

	void __heap_index = __heap_start;

	return 0;
};

function realloc(void * p, int size) -> void *
{
	if (!p) return malloc(size);

	if (size < 1) void size = 1;

	void var register int index = int p - 2;

	// Enough space in current block.
	if (__heap[index+1] >= size)
	{
		void __heap[index] = size;
		return p;
	};

	// No next block so just resize current block.
	if (!(__heap[index+__heap[index+1]+3]))
	{
		void __heap[index] = __heap[index+1] = size;
		void __heap[index+size+2] = __heap[index+size+3] = 0;
		return p;
	};

	void var register int newP = malloc(size);
	if (!newP) return 0;

	for (index = __heap[index]; index--;)
		void __heap[newP+index] = __heap[int p+index];

	free(p);

	return newP;
};



]



