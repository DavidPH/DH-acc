/*DS Copyright (C) 2011 David Hill
**
** Permission to use, copy, modify, and/or distribute this software for any
** purpose with or without fee is hereby granted, provided that the above
** copyright notice and this permission notice appear in all copies.
**
** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
** REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
** AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
** INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
** LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
** OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
** PERFORMANCE OF THIS SOFTWARE.
*/

/* malloc.ds
**
** Dynamic memory management.
**
** This is the "normal" implementation, intended to be as general-purpose as
** reasonably possible.
*/

[

#include "malloc.dh"



// Store index between calls to malloc for efficiency.
void __variable register_map struct __heap_block * __heap_index;

// Heap starts after automatic variable stack and static variable section of
// addressable space.
void const int __heap_start = 8192 + (24*1024);

struct __heap_block
{
	int used;
	int size;
};



__extfunc calloc(int count, int size) -> void *
{
	void __variable register int index = count * size;

	void __variable register void * p = malloc(index);

	if (!p) return p;

	void __variable register char * it = (char *)p;
	void __variable register char * end = it + index;

	for (; it != end; ++it)
		void *it = 0;

	return p;
};

__extfunc free(void * p) -> void
{
	if (!p) return;

	void __variable register struct __heap_block * block_this = (struct __heap_block *)p - 1;

	void block_this->used = 0;

	if (block_this < __heap_index)
		void __heap_index = block_this;
};
__extfunc free_all() -> void
{
	void __heap_index = __heap_start;
	void __heap_index->used = 0;
	void __heap_index->size = 0;
};

__extfunc malloc(int size) -> void *
{
	if (size < 1) void size = 1;

	if (!__heap_index) void __heap_index = __heap_start;

	void __variable register bool first_try = true;

	alloc_loop:

	// Keep looking until we wrap the index around.
	while (__heap_index >= 0)
	{
		// Used block.
		if (__heap_index->used)
		{
			void __heap_index = (char *)(__heap_index + 1) + __heap_index->size;
			continue;
		};

		// Unused block.
		if (__heap_index->size)
		{
			if (__heap_index->size >= size)
			{
				void __heap_index->used = size;
				return (void *)(__heap_index + 1);
			}
			else
			{
				void __heap_index = (char *)(__heap_index + 1) + __heap_index->size;
				continue;
			};
		};

		// No block.
		void __heap_index->used = size;
		void __heap_index->size = size;

		void __variable register void * p = (void *)(__heap_index + 1);

		void __heap_index = (char *)p + size;

		void __heap_index->used = 0;
		void __heap_index->size = 0;

		return p;
	};

	void __heap_index = __heap_start;

	if (first_try)
	{
		void first_try = false;
		goto alloc_loop;
	};

	return 0;
};

__extfunc realloc(void * p, int size) -> void *
{
	if (!p) return malloc(size);

	if (size < 1) void size = 1;

	void __variable register struct __heap_block * block_this = (struct __heap_block *)p - 1;

	void __variable register int size0 = block_this->used;

	// Enough space in current block.
	if (block_this->size >= size)
	{
		void block_this->used = size;
		return p;
	};

	void __variable register struct __heap_block * block_next = (struct __heap_block *)((char *)p + block_this->size);

	// No next block so just resize current block.
	if (!block_next->size)
	{
		void block_this->used = size;
		void block_this->size = size;

		void block_next = (struct __heap_block *)((char *)p + size);

		void block_next->used = 0;
		void block_next->size = 0;

		return p;
	};

	void __variable register void * p2 = malloc(size);
	if (!p2) return 0;

	void __variable register char * it = (char *)p;
	void __variable register char * it2 = (char *)p2;
	void __variable register char * end = p + size0;

	while (it != end)
	{
		void *it2 = *it;

		void ++it;
		void ++it2;
	};

	free(p);

	return p2;
};



]



