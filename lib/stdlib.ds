//-----------------------------------------------------------------------------
//
// Copyright(C) 2011, 2012 David Hill
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//
//-----------------------------------------------------------------------------
//
// General utilities.
//
//-----------------------------------------------------------------------------

#include "stdlib.dh"

#include "string.dh"


//----------------------------------------------------------------------------|
// Macros                                                                     |
//

//
// __LIBDS_HEAPSIZE
//
// Specifies the size of the dynamic memory heap in megabytes.
//
#ifndef __LIBDS_HEAPSIZE
#define __LIBDS_HEAPSIZE 16
#endif


//----------------------------------------------------------------------------|
// Types                                                                      |
//

//
// exitdata
//
struct exitdata
{
   bool isScript;
   union
   {
      __func_t()   f;
      __script_t() s;
   } func;
};

//
// heapdata
//
struct heapdata
{
   unsigned size;
   unsigned used;
   char[0] data;
};


//----------------------------------------------------------------------------|
// Static Variables                                                           |
//

constexpr size_t exitsize = 256;

__intvar __staticarray exitdata[exitsize] exitarr;
__intvar __staticregister decltype(*exitarr) *exitptr = exitarr;

constexpr decltype(*exitarr) *exitbegin = &exitarr[0];
constexpr decltype(*exitarr) *exitend = &exitarr[exitsize];


constexpr size_t heapsize = __LIBDS_HEAPSIZE * 1024 * 1024;

__intvar static char[heapsize] heap;
__intvar __staticregister heapdata *heapptr = (heapdata *)heap;

constexpr heapdata *heapbegin = (heapdata *)&heap[0];
constexpr heapdata *heapend = (heapdata *)&heap[heapsize];


__intvar __staticregister unsigned randval = 1;


//----------------------------------------------------------------------------|
// Global Functions                                                           |
//

//===================================================================
// Numeric conversion functions.
//

//
// atof
//
__function float atof(char const *nptr)
{
   //return 0;
};

//
// atoi
//
__function int atoi(char const *nptr)
{
   return 0;
};

//
// atol
//
__function long atol(char const *nptr)
{
   return 0;
};

//
// atoll
//
__function long long atoll(char const *nptr)
{
   return 0;
};

//
// strtod
//
__function double strtod(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   //return 0;
};

//
// strtof
//
__function float strtof(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   //return 0;
};

//
// strtold
//
__function long double strtold(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   //return 0;
};

//
// strtol
//
__function long strtol(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//
// strtoll
//
__function long long strtoll(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//
// strtoul
//
__function unsigned long strtoul(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//
// strtoull
//
__function unsigned long long strtoull(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//===================================================================
// Pseudo-random sequence generation functions.
//

//
// rand
//
__extfunc rand() -> int
{
   randval = randval * 1103515245 + 12345;
   return (unsigned)(randval >> 8) & RAND_MAX;
};

//
// srand
//
__extfunc srand(unsigned int seed) -> void
{
   randval = seed;
};

//===================================================================
// Memory management functions.
//

//
// calloc
//
__extfunc calloc(size_t nmemb, size_t size) -> void *
{
   nmemb = (size_t)malloc(size *= nmemb);

   if (!nmemb) return NULL;

   char *ptr = (char *)nmemb;
   char *end = ptr + size;

   while (ptr != end) {*ptr++ = 0;};

   return (void *)nmemb;
};

//
// free
//
__extfunc free(void *ptr) -> void
{
   if (!ptr) return;

   heapdata *block = (heapdata *)ptr - 1;

   block->used = 0;

   if (block < heapptr) {heapptr = block;};
};

//
// malloc
//
__extfunc malloc(size_t size) -> void *
{
   if (!size) return NULL;

   if (!heapptr) {heapptr = heapbegin;};

   while (true)
   {
      // Used block.
      if (heapptr->used)
      {
         heapptr = (heapdata *)&heapptr->data[heapptr->size];
         continue;
      };

      // Unused block.
      if (heapptr->size)
      {
         if (heapptr->size >= size)
         {
            heapptr->used = size;
            return (void *)&heapptr->data;
         }
         else
         {
            heapptr = (heapdata *)&heapptr->data[heapptr->size];
            continue;
         };
      };

      // No block.

      // Verify that there is sufficient space first.
      if ((heapdata *)&heapptr->data[size]+1 >= heapend)
         return NULL;

      heapptr->used = size;
      heapptr->size = size;

      void *ptr = (void *)&heapptr->data;

      heapptr = (heapdata *)&heapptr->data[heapptr->size];

      heapptr->used = 0;
      heapptr->size = 0;

      return ptr;
   };

   heapptr = heapbegin;

   return NULL;
};

//
// realloc
//
__extfunc realloc(void *ptr, size_t size) -> void *
{
   if (!ptr) return malloc(size);

   if (!size) {free(ptr); return NULL;};

   heapdata *block = (heapdata *)ptr - 1;

   // Enough size in current block.
   if (block->size >= size)
   {
      block->used = size;

      return ptr;
   };

   heapdata *nextblock = (heapdata *)&block->data[block->size];

   // No next block, just resize current block. (If enough space.)
   if (nextblock->size == 0 && (heapdata *)&block->data[size]+1 < heapend)
   {
      block->size = size;
      block->used = size;

      nextblock = (heapdata *)&block->data[block->size];

      nextblock->size = 0;
      nextblock->used = 0;

      return ptr;
   };

   void *newptr = malloc(size);

   if (!newptr) return NULL;

   memcpy(newptr, ptr, block->used);

   free(ptr);

   return newptr;
};

//===================================================================
// Communication with the environment.
//

//
// abort
//
__extfunc void abort()
{
   #if defined(__TARGET_ZDoom__)
   *(int *)NULL = 0xDEADC0DE; // Flag abort.
   __printf<__printf_log>("Aborted.");
   (__linespec() @ 243)();
   (__asmfunc() @ __ocode(ACS_SCRIPT_TERMINATE))();
   #else
   __printf<__printf_error>("Aborted.");
   #endif
};

//
// atexit
//
__extfunc int atexit(__func_t() func)
{
   if (exitptr == exitend) return 1;

   #if defined(__TAGET_ZDoom__)
   return 1;
   #else
   exitptr->isScript = false;
   exitptr->func.f = func;
   exitptr++;
   return 0;
   #endif
};

//
// __atexit_script
//
__extfunc int __atexit_script(__script_t() func)
{
   if (exitptr == exitend) return 1;

   exitptr->isScript = true;
   exitptr->func.s = func;
   exitptr++;
   return 0;
};

//
// exit
//
__extfunc void exit(int status)
{
   while (exitptr != exitbegin)
   {
      if ((--exitptr)->isScript)
      {
         exitptr->func.s();
      }
      else
      {
         #if defined(__TARGET_ZDoom__)
         __printf<__printf_log>("Cannot call atexit function.");
         #else
         exitptr->func.f();
         #endif
      };
   };

   _Exit(status);
};

//
// _Exit
//
__extfunc void _Exit(int status)
{
   if (status & 1)
   {
      (__linespec(int) @ 244)(status >> 1);
   }
   else
   {
      (__linespec(int) @ 243)(status >> 1);
   };

   (__asmfunc() @ __ocode(ACS_SCRIPT_TERMINATE))();
};

//
// getenv
//
__extfunc char *getenv(char const *name)
{
   return NULL;
};

//
// system
//
__extfunc int system(char const *string)
{
   if (!string) return 0;

   return 0;
};

//===================================================================
// Searching and sorting utilities.
//

//
// bsearch
//
// Like qsort below, this is more for reference than anything.
//
// Don't compile for ZDoom, due to lack of function-pointers.
//
__function void *bsearch (void const *key, void const *base, size_t nmemb,
   size_t size, __func_t(void const *, void const *) -> int compar)
{
#if !defined(__TARGET_ZDoom__)
   int cmp;
   char const *begin = static_cast<char const *>(base);
   char const *end = begin + nmemb*size;
   char const *itr;

   while (begin != end)
   {
      // itr = begin + (end - begin) / 2
      itr = begin + ((((end - begin) / size) / 2) * size);

      if (!(cmp = compar(key, itr))) return (void *)itr;

      if (cmp < 0) {end = itr;} else {begin = itr;};
   };
#endif

   return NULL;
};

//
// qsort
//
// Probably not the best algorithm, but it can serve as a base for a customized
// version. (Which is highly likely to be needed. Even if it took __script_t,
// it would still require static* inputs.)
//
// Don't compile for ZDoom, due to lack of function-pointers.
//
__extfunc qsort(void *base, size_t nmemb, size_t size,
 __func_t(void const *, void const *) -> int compar) -> void
{
#if !defined(__TARGET_ZDoom__)
   char *iter = (char *)base;
   char *end = (char *)base + nmemb*size;

   while (iter != end)
   {
      // If iter >= iter+1...
      if (compar(iter, iter+size) >= 0)
      {
         // Swap the two elements.
         __memswp(iter, iter+size, size);

         // Reset the iterator.
         if (iter != base) (iter -= size);

         continue;
      };

      iter += size;
   };
#endif
};

//===================================================================
// Integer arithmetic functions.
//

//
// abs
//
__extfunc abs(int j) -> int
{
   return j < 0 ? -j : j;
};

//
// labs
//
__extfunc labs(long int j) -> long int
{
   return j < 0 ? -j : j;
};

//
// llabs
//
__extfunc llabs(long long int j) -> long long int
{
   return j < 0 ? -j : j;
};

//
// div
//
// "operator /"
//
__extfunc div(int numer, int denom) -> div_t
{
   div_t d;
   d.quot = numer / denom;
   d.rem  = numer % denom;
   return d;
};

//
// ldiv
//
// "operator /"
//
__extfunc ldiv(long int numer, long int denom) -> ldiv_t
{
   ldiv_t d;
   d.quot = numer / denom;
   d.rem  = numer % denom;
   return d;
};

//
// lldiv
//
// "operator /"
//
__extfunc lldiv(long long int numer, long long int denom) -> lldiv_t
{
   lldiv_t d;
#if 0
   d.quot = numer / denom;
   d.rem  = numer % denom;
#else
   d.quot = 0;
   d.rem  = numer;
#endif
   return d;
};

//===================================================================
// Multibyte/wide character conversion functions.
//

//
// mblen
//
__function int mblen(char const *s, size_t n)
{
   if(!s) return 0;

   if(!n) return -1;

   return 1;
};

//
// mbtowc
//
__function int mbtowc(wchar_t *restrict pwc, char const *restrict s, size_t n)
{
   if(!s) return 0;

   if(!n) return -1;

   if(pwc) *pwc = *s;

   return 1;
};

//
// wctomb
//
__function int wctomb(char *s, wchar_t wc)
{
   if(!s) return 0;

   *s = wc;

   return 1;
};

//===================================================================
// Multibyte/wide string conversion functions.
//

//
// mbstowcs
//
__function size_t mbstowcs(wchar_t *restrict pwcs, char const *restrict s, size_t n)
{
   size_t i = 0;

   while(*s)
   {
      if(i++ == n) return n;

      *pwcs++ = *s++;
   };

   *pwcs = 0;

   return i;
};

//
// wcstombs
//
__function size_t wcstombs(char *restrict s, wchar_t const *restrict pwcs, size_t n)
{
   size_t i = 0;

   while(*pwcs)
   {
      if(i++ == n) return n;

      *s++ = *pwcs++;
   };

   *s = 0;

   return i;
};

// EOF

