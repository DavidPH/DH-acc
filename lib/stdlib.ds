//-----------------------------------------------------------------------------
//
// Copyright(C) 2011, 2012 David Hill
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//
//-----------------------------------------------------------------------------
//
// General utilities.
//
//-----------------------------------------------------------------------------

#include "stdlib.h"

#include "string.h"


//----------------------------------------------------------------------------|
// Macros                                                                     |
//

//
// __LIBDS_HEAPSIZE
//
// Specifies the size of the dynamic memory heap in megabytes.
//
#ifndef __LIBDS_HEAPSIZE
#define __LIBDS_HEAPSIZE 16
#endif

#define EXITSIZE  (256)
#define EXITBEGIN (&exitarr[0])
#define EXITEND   (&exitarr[EXITSIZE])

#define HEAPSIZE  (__LIBDS_HEAPSIZE * 1024 * 1024)
#define HEAPBEGIN ((heapdata static *)&heap[0])
#define HEAPEND   ((heapdata static *)&heap[HEAPSIZE])


//----------------------------------------------------------------------------|
// Types                                                                      |
//

//
// heapdata
//
struct heapdata
{
   unsigned size;
   unsigned used;
   char[0] data;
};


//----------------------------------------------------------------------------|
// Static Variables                                                           |
//

__intvar __staticarray __func_t()[EXITSIZE] exitarr;
__intvar __staticregister decltype(*exitarr) *exitptr = exitarr;


__intvar static char[HEAPSIZE] heap;
__intvar __staticregister heapdata static *heapptr = HEAPBEGIN;


__intvar __staticregister unsigned randval = 1;


//----------------------------------------------------------------------------|
// Global Functions                                                           |
//

//===================================================================
// Numeric conversion functions.
//

//
// atof
//
__extfunc "C" double atof(char const *nptr)
{
   //return 0;
};

//
// atoi
//
__extfunc "C" int atoi(char const *nptr)
{
   return 0;
};

//
// atol
//
__extfunc "C" long atol(char const *nptr)
{
   return 0;
};

//
// atoll
//
__extfunc "C" long long atoll(char const *nptr)
{
   return 0;
};

//
// strtod
//
__extfunc "C" double strtod(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   //return 0;
};

//
// strtof
//
__extfunc "C" float strtof(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   //return 0;
};

//
// strtold
//
__extfunc "C" long double strtold(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   //return 0;
};

//
// strtol
//
__extfunc "C" long strtol(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//
// strtoll
//
__extfunc "C" long long strtoll(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//
// strtoul
//
__extfunc "C" unsigned long strtoul(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//
// strtoull
//
__extfunc "C" unsigned long long strtoull(char const *restrict nptr, char **restrict endptr)
{
   if(endptr) *endptr = NULL;
   return 0;
};

//===================================================================
// Pseudo-random sequence generation functions.
//

//
// rand
//
__extfunc "C" int rand()
{
   randval = randval * 1103515245 + 12345;
   return (unsigned)(randval >> 8) & RAND_MAX;
};

//
// srand
//
__extfunc "C" void srand(unsigned int seed)
{
   randval = seed;
};

//===================================================================
// Memory management functions.
//

//
// calloc
//
__extfunc "C" void *calloc(size_t nmemb, size_t size)
{
   void *ptr = malloc(size *= nmemb);

   if(!ptr) return NULL;

   return memset(ptr, 0, size);
};

//
// free
//
__extfunc "C" void free(void *ptr)
{
   if(!ptr) return;

   heapdata static *block = __force_cast<heapdata static *>(ptr) - 1;

   block->used = 0;

   if(block < heapptr) heapptr = block;
};

//
// malloc
//
__extfunc "C" void *malloc(size_t size)
{
   if(!size) return NULL;

   if(!heapptr) heapptr = HEAPBEGIN;

   while(true)
   {
      // Used block.
      if(heapptr->used)
      {
         heapptr = (heapdata static *)&heapptr->data[heapptr->size];
         continue;
      };

      // Unused block.
      if(heapptr->size)
      {
         if (heapptr->size >= size)
         {
            heapptr->used = size;
            return (void static *)&heapptr->data;
         }
         else
         {
            heapptr = (heapdata static *)&heapptr->data[heapptr->size];
            continue;
         };
      };

      // No block.

      // Verify that there is sufficient space first.
      if((heapdata static *)&heapptr->data[size] + 1 >= HEAPEND)
         return NULL;

      heapptr->used = size;
      heapptr->size = size;

      void static *ptr = (void static *)&heapptr->data;

      heapptr = (heapdata static *)&heapptr->data[heapptr->size];

      heapptr->used = 0;
      heapptr->size = 0;

      return ptr;
   };

   heapptr = HEAPBEGIN;

   return NULL;
};

//
// realloc
//
__extfunc "C" void *realloc(void *ptr, size_t size)
{
   if(!ptr) return malloc(size);

   if(!size) {free(ptr); return NULL;};

   heapdata static *block = __force_cast<heapdata static *>(ptr) - 1;

   // Enough size in current block.
   if(block->size >= size)
   {
      block->used = size;

      return ptr;
   };

   heapdata static *nextblock = (heapdata static *)&block->data[block->size];

   // No next block, just resize current block. (If enough space.)
   if(nextblock->size == 0 && (heapdata *)&block->data[size]+1 < HEAPEND)
   {
      block->size = size;
      block->used = size;

      nextblock = (heapdata static *)&block->data[block->size];

      nextblock->size = 0;
      nextblock->used = 0;

      return ptr;
   };

   void *newptr = malloc(size);

   if(!newptr) return NULL;

   memcpy(newptr, ptr, block->used);

   free(ptr);

   return newptr;
};

//===================================================================
// Communication with the environment.
//

//
// abort
//
__extfunc "C" void abort()
{
   #if defined(__TARGET_ZDoom__)
   *(int *)NULL = 0xDEADC0DE; // Flag abort.
   __printf<__printf_log>("Aborted.");
   (__linespec() @ 243)();
   (__asmfunc() @ __ocode(ACS_SCRIPT_TERMINATE))();
   #else
   __printf<__printf_error>("Aborted.");
   #endif
};

//
// atexit
//
__extfunc "C" int atexit(__func_t() func)
{
   if(exitptr == EXITEND) return 1;

   *exitptr++ = func;

   return 0;
};

//
// exit
//
__extfunc "C" void exit(int status)
{
   while(exitptr-- != EXITBEGIN)
      (*exitptr)();

   _Exit(status);
};

//
// _Exit
//
__extfunc "C" void _Exit(int status)
{
   if(status & 1)
   {
      (__linespec(int) @ 244)(status >> 1);
   }
   else
   {
      (__linespec(int) @ 243)(status >> 1);
   };

   (__asmfunc() @ __ocode(ACS_SCRIPT_TERMINATE))();
};

//
// getenv
//
__extfunc "C" char *getenv(char const *name)
{
   return NULL;
};

//
// system
//
__extfunc "C" int system(char const *string)
{
   if(!string) return 0;

   return 0;
};

//===================================================================
// Searching and sorting utilities.
//

//
// bsearch
//
__extfunc "C" void *bsearch(void const *key, void const *base, size_t nmemb, size_t size,
                            __func_t(void const *, void const *) -> int compar)
{
   int cmp;
   char const *begin = reinterpret_cast<char const *>(base);
   char const *end = begin + nmemb*size;
   char const *itr;

   while(begin != end)
   {
      // itr = begin + (end - begin) / 2
      itr = begin + ((((end - begin) / size) / 2) * size);

      if(!(cmp = compar(key, itr))) return (void *)itr;

      if(cmp < 0) end = itr else begin = itr;
   };

   return NULL;
};

//
// qsort
//
__extfunc "C" void qsort(void *base, size_t nmemb, size_t size,
                         __func_t(void const *, void const *) -> int compar)
{
   char *itr = (char *)base;
   char *end = (char *)base + nmemb*size;

   while(itr != end)
   {
      // If iter >= iter+1...
      if(compar(itr, itr+size) >= 0)
      {
         // Swap the two elements.
         memswp(itr, itr+size, size);

         // Reset the iterator.
         if(itr != base) itr -= size;

         continue;
      };

      itr += size;
   };
};

//===================================================================
// Integer arithmetic functions.
//

//
// abs
//
__extfunc "C" int abs(int j)
{
   return j < 0 ? -j : j;
};

//
// labs
//
__extfunc "C" long labs(long int j)
{
   return j < 0 ? -j : j;
};

//
// llabs
//
__extfunc "C" long long llabs(long long int j)
{
   return j < 0 ? -j : j;
};

//
// div
//
// "operator /"
//
__extfunc "C" div_t div(int numer, int denom)
{
   div_t d;
   d.quot = numer / denom;
   d.rem  = numer % denom;
   return d;
};

//
// ldiv
//
// "operator /"
//
__extfunc "C" ldiv_t ldiv(long int numer, long int denom)
{
   ldiv_t d;
#if 0
   d.quot = numer / denom;
   d.rem  = numer % denom;
#else
   d.quot = 0;
   d.rem  = numer;
#endif
   return d;
};

//
// lldiv
//
// "operator /"
//
__extfunc "C" lldiv_t lldiv(long long int numer, long long int denom)
{
   lldiv_t d;
#if 0
   d.quot = numer / denom;
   d.rem  = numer % denom;
#else
   d.quot = 0;
   d.rem  = numer;
#endif
   return d;
};

//===================================================================
// Multibyte/wide character conversion functions.
//

//
// mblen
//
__extfunc "C" int mblen(char const *s, size_t n)
{
   if(!s) return 0;

   if(!n) return -1;

   return 1;
};

//
// mbtowc
//
__extfunc "C" int mbtowc(wchar_t *restrict pwc, char const *restrict s, size_t n)
{
   if(!s) return 0;

   if(!n) return -1;

   if(pwc) *pwc = *s;

   return 1;
};

//
// wctomb
//
__extfunc "C" int wctomb(char *s, wchar_t wc)
{
   if(!s) return 0;

   *s = wc;

   return 1;
};

//===================================================================
// Multibyte/wide string conversion functions.
//

//
// mbstowcs
//
__extfunc "C" size_t mbstowcs(wchar_t *restrict pwcs, char const *restrict s, size_t n)
{
   size_t i = 0;

   while(*s)
   {
      if(i++ == n) return n;

      *pwcs++ = *s++;
   };

   *pwcs = 0;

   return i;
};

//
// wcstombs
//
__extfunc "C" size_t wcstombs(char *restrict s, wchar_t const *restrict pwcs, size_t n)
{
   size_t i = 0;

   while(*pwcs)
   {
      if(i++ == n) return n;

      *s++ = *pwcs++;
   };

   *s = 0;

   return i;
};

//===================================================================
// Implementation extensions.
//

#define CASE256(N) CASE128((N)); CASE128((N)+128)
#define CASE128(N) CASE64((N)); CASE64((N)+64)
#define CASE64(N) CASE32((N)); CASE32((N)+32)
#define CASE32(N) CASE16((N)); CASE16((N)+16)
#define CASE16(N) CASE8((N)); CASE8((N)+8)
#define CASE8(N) CASE4((N)); CASE4((N)+4)
#define CASE4(N) CASE2((N)); CASE2((N)+2)
#define CASE2(N) CASE1((N)); CASE1((N)+1)

__asmfunc _PushREG(void register *) @ __ocode(NONE, GET_REG);
__asmfunc int _GetWLDARR(int) @ __ocode(NONE, GET_WLDARR);
__asmfunc int _GetGBLARR(int) @ __ocode(NONE, GET_GBLARR);
__asmfunc _SetWLDARR(int) @ __ocode(NONE, SET_WLDARR);
__asmfunc _SetGBLARR(int) @ __ocode(NONE, SET_GBLARR);

typedef struct {unsigned t, i;} _Farptr;

//
// _Getptr
//
__extfunc "C" int _Getptr(void const __far *p)
{
   constexpr _Farptr register *s = (_Farptr register *)&p;

   switch(s->t & 0xC0000000)
   {
   case 0x00000000: // STORE_STATIC
      return *(int const static *)s->i;

   case 0x40000000: // STORE_STRING
      s->t &=       ~0xC0000000;
      s->t |= s->i & 0xC0000000;
      s->i &=       ~0xC0000000;
      return **(__strptr register *)s;

   case 0x80000000: // STORE_WLDARR, STORE_GBLARR
      switch(s->t & ~0xC0000000)
      {
      default: return 0;
      #define CASE1(N) case (N): _PushREG(&s->i); return _GetWLDARR((N));
      CASE256(0);
      #define CASE1(N) case (N)|0x10000: _PushREG(&s->i); return _GetGBLARR((N));
      CASE256(0);
      };

   case 0xC0000000: // STORE_MAPARR
      return 0;
   };
};

//
// _Setptr
//
__extfunc "C" void _Setptr(int v, void __far *p)
{
   constexpr _Farptr register *s = (_Farptr register *)&p;

   switch(s->t & 0xC0000000)
   {
   case 0x00000000: // STORE_STATIC
      *(int static *)s->i = v;
      return;

   case 0x40000000: // STORE_STRING
      return;

   case 0x80000000: // STORE_WLDARR, STORE_GBLARR
      switch(s->t & ~0xC0000000)
      {
      default: return;
      #define CASE1(N) case (N): _PushREG(&s->i); _PushREG(&v); _SetWLDARR((N)); return;
      CASE256(0);
      #define CASE1(N) case (N)|0x10000: _PushREG(&s->i); _PushREG(&v); _SetGBLARR((N)); return;
      CASE256(0);
      };

   case 0xC0000000: // STORE_MAPARR
      return;
   };
};

//
// _Ursh
//
__extfunc "C" unsigned _Ursh(unsigned u, int v)
{
   if(!v) return u;

   *(int register *)&u >>= v;
   return u & ~((int)0x80000000 >> --v);
};

// EOF

